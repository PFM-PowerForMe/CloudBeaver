####################################################
# SQL helpers
####################################################

type SQLDialectInfo {
    name: String!

    dataTypes: [ String ]!
    functions: [ String ]!
    reservedWords: [ String ]!
    quoteStrings: [ [ String ] ]!
    singleLineComments: [ String ]!
    multiLineComments: [ [ String ] ]!

    catalogSeparator: String
    structSeparator: String
    scriptDelimiter: String

    supportsExplainExecutionPlan: Boolean!

}

type SQLCompletionProposal {
    displayString: String!
    type: String!
    score: Int

    replacementString: String!
    replacementOffset: Int!
    replacementLength: Int!
    cursorPosition: Int

    icon: String
    nodePath: String
}

####################################################
# Data read / SQL execution
####################################################

# SQL context must be created for each SQL editor
type SQLContextInfo {

    id: ID!
    projectId: ID!
    connectionId: ID!
    autoCommit: Boolean
    defaultCatalog: String
    defaultSchema: String

}

input SQLDataFilterConstraint {
    attributePosition: Int!
    orderPosition: Int
    orderAsc: Boolean

    criteria: String
    operator: String
    value: Object
}

input SQLDataFilter {
    "Row offset. We use Float because offset may be bigger than 32 bit."
    offset: Float
    limit: Int

    constraints: [ SQLDataFilterConstraint ]
    where: String
    orderBy: String
}

type SQLResultColumn {
    position: Int!
    name: String
    label: String
    icon: String
    entityName: String

    dataKind: String
    typeName: String
    fullTypeName: String
    "Column value max length. We use Float because it may be bigger than 32 bit"
    maxLength: Float
    scale: Int
    precision: Int

    required: Boolean!
    autoGenerated: Boolean!

    readOnly: Boolean!
    readOnlyStatus: String

    "Operations supported for this attribute"
    supportedOperations: [DataTypeLogicalOperation!]!

    "Description of the column"
    description: String @since(version: "25.1.3")
}

type SQLResultRowMetaData {
    data: [Object]!
    metaData: Object
}

type DatabaseDocument {
    id: String
    contentType: String
    properties: Object
    data: Object
}

type SQLResultSet {
    "Result set ID"
    id: ID!
    "Returns list of columns in the result set"
    columns: [ SQLResultColumn ]
    "Returns list of rows in the result set. Each row is an array of column values"
    rows: [ [ Object ] ] @deprecated(reason: "use rowsWithMetaData (23.3.5)")
    "Returns list of rows in the result set. Each row contains data and metadata"
    rowsWithMetaData: [SQLResultRowMetaData] @since(version: "23.3.5")

    # True means that resultset was generated by single entity query
    # New rows can be added, old rows can be deleted
    singleEntity: Boolean!
    # server always returns hasMoreData = false
    hasMoreData: Boolean!
    "Identifies if result set has row identifier. If true then it is possible update data or load LOB files"
    hasRowIdentifier: Boolean!
    "Identifies if result has children collections. If true then children collections can be read from the result set"
    hasChildrenCollection: Boolean!
    "Identifies if result set supports dynamic trace. If true then dynamic trace can be read from the result set"
    hasDynamicTrace: Boolean! @since(version: "24.1.2")
    "Identifies if result set supports data filter. If true then data filter can be applied to the result set"
    isSupportsDataFilter: Boolean!
    "Identifies if result set is read-only. If true then no updates are allowed"
    readOnly: Boolean! @since(version: "25.0.1")
    "Status of read-only result set. If readOnly is true then this field contains reason why result set is read-only"
    readOnlyStatus: String @since(version: "25.0.1")
}

type SQLQueryResults {
    title: String
    updateRowCount: Float
    sourceQuery: String

    # Actual data format of this result
    dataFormat: ResultDataFormat

    resultSet: SQLResultSet
}

type SQLExecuteInfo {

    # Status message
    statusMessage: String
    # Execute time (ms)
    duration: Int!
    # Actual conditions applied to query
    filterText: String
#    # original sql query without SQLDataFilter
#    originalQuery: String
    # Full query that was executed, contains all used filters
    fullQuery: String
    # Results
    results: [ SQLQueryResults! ]!
}

input SQLResultRow {
    data: [ Object ]!
    updateValues: Object
    metaData: Object
}

input SQLResultRowMetaDataInput {
    data: [Object]
    metaData: Object!
}

type DataTypeLogicalOperation {
    id: ID!
    expression: String!
    argumentCount: Int
}

####################################################
# SQL Execution plan
####################################################

type SQLExecutionPlan {
    query: String!
    nodes: [SQLExecutionPlanNode!]!
}

type SQLExecutionPlanNode {
    id: ID!
    parentId: ID

    kind: String!
    name: String
    type: String!
    condition: String
    description: String
    properties: [ObjectPropertyInfo!]!
}

####################################################
# SQL Generation
####################################################

type SQLQueryGenerator {
    id: String!
    label: String!
    description: String
    order: Int!
    multiObject: Boolean!
}

####################################################
# SQL Query info
####################################################
type SQLScriptInfo {
    queries: [ SQLScriptQuery! ]!
}

type SQLScriptQuery {
    start: Int!
    end: Int!
}

####################################################
# Dynamic trace info
####################################################
type DynamicTraceProperty {
    name: String!
    value: String
    description: String
}

####################################################
# Transactional info
####################################################
type TransactionLogInfoItem {
    id: Int!
    time: DateTime!
    type: String!
    queryString: String!
    durationMs: Int!
    rows: Int!
    result: String!
}
type TransactionLogInfos {
    count: Int!
    transactionLogInfos: [TransactionLogInfoItem!]!
}


####################################################
# Query and Mutation
####################################################

extend type Query {

    "Returns SQL dialect info for the specified connection"
    sqlDialectInfo( projectId: ID, connectionId: ID! ): SQLDialectInfo

    "Lists SQL contexts for a connection (optional) or returns the particular context info"
    sqlListContexts( projectId: ID, connectionId: ID, contextId: ID ): [ SQLContextInfo ]!

    "Returns proposals for SQL completion at the specified position in the query"
    sqlCompletionProposals(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        query: String!,
        position: Int!,
        maxResults: Int,
        simpleMode: Boolean
    ): [ SQLCompletionProposal ]

    "Formats SQL query and returns formatted query string"
    sqlFormatQuery(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        query: String!
    ): String!

    "Returns suported operations for the specified attribute index in the results"
    sqlSupportedOperations(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,
        attributeIndex: Int!
    ): [DataTypeLogicalOperation!]!

    "Returns list of all available entity query generators"
    sqlEntityQueryGenerators(nodePathList: [String!]!): [SQLQueryGenerator!]!

    """
    Generates SQL query for the specified entity query generator.
    Available options:
    fullyQualifiedNames - Use fully qualified names for entities
    compactSQL - Use compact SQL format
    showComments - Show comments in generated SQL
    showPermissions - Show permissions in generated SQL
    showFullDdl - Show full DDL in generated SQL
    excludeAutoGeneratedColumn - Exclude auto-generated columns in generated SQL
    useCustomDataFormat - Use custom data format for generated SQL
    """
    sqlGenerateEntityQuery(
        generatorId: String!,
        options: Object!,
        nodePathList: [String!]!
    ): String!

    "Parses SQL script and returns script info with queries start and end positions"
    sqlParseScript(
        projectId: ID,
        connectionId: ID!,
        script: String!
    ): SQLScriptInfo!

    "Parses SQL query and returns query info with start and end positions"
    sqlParseQuery(
        projectId: ID,
        connectionId: ID!,
        script: String!,
        position: Int!
    ): SQLScriptQuery!

    "Generates SQL query for grouping data in the specified results"
    sqlGenerateGroupingQuery(
        projectId: ID,
        contextId: ID!,
        connectionId: ID!,
        resultsId: ID!,
        columnNames: [String!],
        functions: [String!],
        showDuplicatesOnly: Boolean
    ): String!
}

extend type Mutation {
    "Creates SQL context for the specified connection"
    sqlContextCreate( projectId: ID, connectionId: ID!, defaultCatalog: String, defaultSchema: String ): SQLContextInfo!

    "Sets SQL context defaults"
    sqlContextSetDefaults( projectId: ID, connectionId: ID!, contextId: ID!, defaultCatalog: ID, defaultSchema: ID ): Boolean!

    "Destroys SQL context and closes all results"
    sqlContextDestroy( projectId: ID, connectionId: ID!, contextId: ID! ): Boolean!

    "Creates async task for executing SQL query"
    asyncSqlExecuteQuery(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        sql: String!,
        resultId: ID,
        filter: SQLDataFilter,
        dataFormat: ResultDataFormat,   # requested data format. May be ignored by server
        readLogs: Boolean               # added 23.2.1
    ): AsyncTaskInfo!

    "Creates async task for reading data from the container node"
    asyncReadDataFromContainer(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        containerNodePath: ID!,
        resultId: ID,
        filter: SQLDataFilter,
        dataFormat: ResultDataFormat
    ): AsyncTaskInfo!

    "Returns transaction log info for the specified project, connection and context"
    getTransactionLogInfo(
        projectId: ID!,
        connectionId: ID!,
        contextId: ID!
    ): TransactionLogInfos!

    "Closes SQL results (free resources)"
    sqlResultClose(projectId: ID, connectionId: ID!, contextId: ID!, resultId: ID!): Boolean!

    "Creates async task for updating results data in batch mode"
    asyncUpdateResultsDataBatch(
        projectId: ID!,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,

        updatedRows: [SQLResultRow!],
        deletedRows: [SQLResultRow!],
        addedRows: [SQLResultRow!],
    ): AsyncTaskInfo! @since(version: "25.0.0")

    "Synchronously updates results data in batch mode"
    updateResultsDataBatch(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,

        updatedRows: [ SQLResultRow! ],
        deletedRows: [ SQLResultRow! ],
        addedRows: [ SQLResultRow! ],
    ): SQLExecuteInfo! @deprecated(reason: "use async function (25.0.0)")

    "Returns SQL script for cell values update"
    updateResultsDataBatchScript(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,

        updatedRows: [ SQLResultRow! ],
        deletedRows: [ SQLResultRow! ],
        addedRows: [ SQLResultRow! ],
    ): String!

    "Returns BLOB value"
    readLobValue(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,
        lobColumnIndex: Int!,
        row: [ SQLResultRow! ]!
    ): String! @deprecated(reason: "use sqlReadLobValue (23.3.3)")

    "Returns BLOB value as Base64 encoded string"
    sqlReadLobValue(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,
        lobColumnIndex: Int!,
        row: SQLResultRow!
    ): String! @since(version: "23.3.3")

    "Returns full string value ignoring any limits"
    sqlReadStringValue(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,
        columnIndex: Int!,
        row: SQLResultRow!
    ): String! @since(version: "23.3.3")

    "Returns SQL execution results for async SQL execute task"
    asyncSqlExecuteResults(taskId: ID!): SQLExecuteInfo !

    "Creates async task to generating SQL execution plan"
    asyncSqlExplainExecutionPlan(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        query: String!,
        configuration: Object!
    ): AsyncTaskInfo!

    "Returns SQL execution plan for async SQL explain task"
    asyncSqlExplainExecutionPlanResult(taskId: ID!): SQLExecutionPlan !

    "Creates async task to count rows in SQL results"
    asyncSqlRowDataCount(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!
    ): AsyncTaskInfo!

    "Returns row count for async SQL row data count task"
    asyncSqlRowDataCountResult(taskId: ID!): Int!

    "Reads dynamic trace from provided database results"
    sqlGetDynamicTrace(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!
    ): [DynamicTraceProperty!]! @since(version: "24.1.2")

    "Creates async task to set auto-commit mode"
    asyncSqlSetAutoCommit(
        projectId: ID!,
        connectionId: ID!,
        contextId: ID!,
        autoCommit: Boolean!
    ): AsyncTaskInfo! @since(version: "24.0.1")

    "Creates async task to commit transaction"
    asyncSqlCommitTransaction(
        projectId: ID!,
        connectionId: ID!,
        contextId: ID!
    ): AsyncTaskInfo! @since(version: "24.0.1")

    "Creates async task to rollback transaction"
    asyncSqlRollbackTransaction(
        projectId: ID!,
        connectionId: ID!,
        contextId: ID!
    ): AsyncTaskInfo! @since(version: "24.0.1")

}
